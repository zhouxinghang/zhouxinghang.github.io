<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"zhouxinghang.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="行到水穷处，坐看云起时"><meta property="og:type" content="website"><meta property="og:title" content="ZBlog"><meta property="og:url" content="https://zhouxinghang.github.io/index.html"><meta property="og:site_name" content="ZBlog"><meta property="og:description" content="行到水穷处，坐看云起时"><meta property="og:locale" content="en_US"><meta property="article:author" content="zhouxinghang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://zhouxinghang.github.io/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>ZBlog</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="ZBlog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">ZBlog</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">day day up</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">zhouxinghang</p><div class="site-description" itemprop="description">行到水穷处，坐看云起时</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">tags</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="Back to top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/hexo5-next8.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/hexo5-next8.html" class="post-title-link" itemprop="url">hexo5-next8 配置</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2021-11-23 13:09:23" itemprop="dateCreated datePublished" datetime="2021-11-23T13:09:23+08:00">2021-11-23</time></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">## 安装 hexo，需要 nodejs</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line">## 安装 next 主题</span><br><span class="line">npm install hexo-theme-next</span><br><span class="line"></span><br><span class="line">## 初始化 next 配置</span><br><span class="line">## hexo5 推荐将主题配置文件放在根目录，命名为：_config.[name].yml</span><br><span class="line">## 下面两种任选一种</span><br><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line">cp themes/next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure><h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><table><thead><tr><th>Hexo version</th><th>Minimum Node.js version</th></tr></thead><tbody><tr><td>5.0+</td><td>10.13.0</td></tr><tr><td>4.1 - 4.2</td><td>8.10</td></tr><tr><td>4.0</td><td>8.6</td></tr><tr><td>3.3 - 3.9</td><td>6.9</td></tr><tr><td>3.2 - 3.3</td><td>0.12</td></tr><tr><td>3.0 - 3.1</td><td>0.10 or iojs</td></tr><tr><td>0.0.1 - 2.8</td><td>0.10</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>站点配置文件 _config.yml<br>主题：<code>theme: next</code><br>站点信息：title<br>hexo 永久链接：url<br>nofollow 减少出站链接</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题： <code>scheme:Gemini</code><br>菜单：menu。需要添加对应页面，如： hexo new page about<br>本地搜索<br>rss 订阅<br>站点的 footer 信息<br>社交信息：social<br>友链：links_icon<br>首页文章不展示全文显示摘要<br>页面阅读统计</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/docs/configuration">https://hexo.io/docs/configuration</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://tding.top/archives/42c38b10.html">https://tding.top/archives/42c38b10.html</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/http-407-fix.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/http-407-fix.html" class="post-title-link" itemprop="url">Http 407 问题排查</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-07-25 19:08:25" itemprop="dateCreated datePublished" datetime="2019-07-25T19:08:25+08:00">2019-07-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/" itemprop="url" rel="index"><span itemprop="name">异常排查</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近接一个新的代理平台出现了大量 Http 请求 407 的错误，主要是 HttpClient 的“延迟认证”导致的，排查原因记录下</p><h2 id="basic-认证"><a href="#basic-认证" class="headerlink" title="basic 认证"></a>basic 认证</h2><p>实现简单，但如果是 http 请求的话，信息会泄露，存在安全风险</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.im/entry/5ac175baf265da239e4e3999">https://juejin.im/entry/5ac175baf265da239e4e3999</a></p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>client -&gt; server：未携带认证信息<br>server -&gt; client：返回407<br>client -&gt; server：携带认证信息<br>server -&gt; client：返回200</p><p>注意这两步在代码层面是无感知的，只会收到最后的200。如果这个tcp连接已经建立，下次请求就会直接携带认证信息</p><p>看看 httpClient 的 debug 日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求报文</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;GET Http://www.baidu.com/ HTTP/1.1[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;Host: www.baidu.com[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;Proxy-Connection: Keep-Alive[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;User-Agent: Apache-HttpClient/4.5.6 (Java/1.8.0_45)[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;Accept-Encoding: gzip,deflate[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.002</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &gt;&gt; <span class="string">&quot;[\r][\n]&quot;</span></span><br><span class="line"><span class="comment">// 返回报文</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;HTTP/1.1 407 Proxy Authentication Required[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;Mime-Version: 1.0[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;Date: Wed, 31 Jul 2019 02:19:45 GMT[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;Content-Type: text/html;charset=utf-8[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;Content-Length: 80[\r][\n]&quot;</span></span><br><span class="line"><span class="number">10</span>:<span class="number">19</span>:<span class="number">46.034</span> [main] DEBUG org.apache.http.wire - http-outgoing-<span class="number">0</span> &lt;&lt; <span class="string">&quot;Proxy-Authenticate: Basic realm=&quot;</span>dobel<span class="string">&#x27;s  server&quot;[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.035 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Connection: keep-alive[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.035 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.035 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;407 Authentication Failed!Maybe Proxy-uthentication header is missing or wrong![\n]&quot;</span></span><br><span class="line"><span class="string">// 第二次请求报文</span></span><br><span class="line"><span class="string">10:19:46.060 [main] DEBUG org.apache.http.headers - http-outgoing-0 &gt;&gt; Proxy-Authorization: Basic TVRIVU9DSEU2RUVHOFFMUTEwOnhtS1FHbmJF</span></span><br><span class="line"><span class="string">10:19:46.060 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;GET Http://www.baidu.com/ HTTP/1.1[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.060 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Host: www.baidu.com[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.061 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Proxy-Connection: Keep-Alive[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.061 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;User-Agent: Apache-HttpClient/4.5.6 (Java/1.8.0_45)[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.061 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Accept-Encoding: gzip,deflate[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.061 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;Proxy-Authorization: Basic TVRIVU9DSEU2RUVHOFFMUTEwOnhtS1FHbmJF[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.061 [main] DEBUG org.apache.http.wire - http-outgoing-0 &gt;&gt; &quot;[\r][\n]&quot;</span></span><br><span class="line"><span class="string">// 第二次返回报文</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;HTTP/1.1 200 OK[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Content-Encoding: gzip[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Content-Type: text/html[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Date: Wed, 31 Jul 2019 02:19:46 GMT[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Pragma: no-cache[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Transfer-Encoding: chunked[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;Connection: keep-alive[\r][\n]&quot;</span></span><br><span class="line"><span class="string">10:19:46.757 [main] DEBUG org.apache.http.wire - http-outgoing-0 &lt;&lt; &quot;[\r][\n]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="抢占式认证"><a href="#抢占式认证" class="headerlink" title="抢占式认证"></a>抢占式认证</h2><p>HttpClient 为了安全考虑，默认是不会发送认证信息的，只有在服务端要求情况下，才回去携带。可以通过直接设置 header 来实现抢先式认证。</p><h2 id="请求方-407-原因"><a href="#请求方-407-原因" class="headerlink" title="请求方 407 原因"></a>请求方 407 原因</h2><p>请求方 HttpClient 在 407 时候会再次请求服务端，这两次请求对上层是透明的。按理说请求方是不知道有 407 的错误的。但是如果在超时时间内未完成这两次请求，HttpClient 就会抛出 407。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.baeldung.com/httpclient-4-basic-authentication">https://www.baeldung.com/httpclient-4-basic-authentication</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/ReentrantLock.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/ReentrantLock.html" class="post-title-link" itemprop="url">ReentrantLock 实现原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-07-07 17:45:14" itemprop="dateCreated datePublished" datetime="2019-07-07T17:45:14+08:00">2019-07-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Lock-简介"><a href="#Lock-简介" class="headerlink" title="Lock 简介"></a>Lock 简介</h2><p>Lock 是 JDK1.5 之后提供的接口，它提供了和 synchronized 类似的同步功能，比 synchronized 更为灵活，能弥补 synchronized 在一些业务场景中的短板。</p><h2 id="Lock-的实现"><a href="#Lock-的实现" class="headerlink" title="Lock 的实现"></a>Lock 的实现</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>可重入，排他，公平/非公平</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio18.svg?sanitize=true" alt="656edd2a54b6e7e2d12eee8b5acf364c.png"></p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>共享&amp;排他，可重入</p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>共享锁</p><h3 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h3><p>共享锁</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>在 Lock 中，用到了一个同步队列 AQS，全称 AbstractQueuedSynchronizer，它是一个同步工具也是 Lock 用来实现线程同步的核心组件。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>内部维护一个 FIFO 的双向链表，链表中的每个节点 Node 都记录了一个线程。当线程获取锁失败时，封装成 Node 加入到 AQS 队列中。当获取锁的线程释放锁时，会从队列中唤醒一个阻塞的线程。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio19.svg?sanitize=true" alt="92c2cc530af01b066840778c43f98a23.png"></p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/86E865E0-52DF-44FB-B492-AA61CFEA23B6.png" alt="da2d5aea6b673cc455edac54d4e3481c.png"></p><p>Node 的 state 状态值在不同的实现类中表示不同的意思，</p><h3 id="竞争锁节点的操作"><a href="#竞争锁节点的操作" class="headerlink" title="竞争锁节点的操作"></a>竞争锁节点的操作</h3><h4 id="竞争成功"><a href="#竞争成功" class="headerlink" title="竞争成功"></a>竞争成功</h4><p>假如第二个节点获取到了锁，head指向获取锁的节点，并断开与 next 的连接（前置节点 next 指向 null）</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio20.svg?sanitize=true" alt="f561203cfae0ef0fe86986468953a37c.png"></p><p>获取到锁的线程（头结点），会重新设置 head 指针，不存在竞争，普通操作即可。</p><h4 id="竞争失败"><a href="#竞争失败" class="headerlink" title="竞争失败"></a>竞争失败</h4><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio21.svg?sanitize=true" alt="19b66fb4c796bdafcd10a7de44afa8a4.png"></p><p>只有 CAS 操作成功了，再去设置尾节点的 prev，此时不存在竞争，普通操作即可。</p><h3 id="ReentrantLock-lock-的源码分析"><a href="#ReentrantLock-lock-的源码分析" class="headerlink" title="ReentrantLock#lock 的源码分析"></a>ReentrantLock#lock 的源码分析</h3><h4 id="lock-操作时序图"><a href="#lock-操作时序图" class="headerlink" title="lock 操作时序图"></a>lock 操作时序图</h4><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio22.svg?sanitize=true" alt="a20045e951f6210a66851e5104e9cc25.png"></p><h4 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync#lock"></a>NonfairSync#lock</h4><p>非公平锁和公平锁的区别是，非公平锁会先尝试修改 state 状态为1，修改成功表示获取锁成功，修改失败，会走 AQS 的 acquire 操作。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/090C1BD5-0DA2-417E-BDC0-7F8DC6080EA6.png" alt="8a589015f47656f44c4874f7bb3cfbe8.png"></p><h4 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS#acquire"></a>AQS#acquire</h4><p>会想尝试获取锁 tryAcquire，获取失败会将当前线程封装成 Node 节点添加到 AQS 队尾 addWaiter，并自旋尝试获取锁 acquireQueued。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/4BC11C7A-329A-42B6-993B-51A9D077DEED.png" alt="db45385397adbe6de234de48641f96ec.png"></p><h4 id="NonfairSync-tryAcquire"><a href="#NonfairSync-tryAcquire" class="headerlink" title="NonfairSync#tryAcquire"></a>NonfairSync#tryAcquire</h4><p>尝试获取锁，成功返回 true，不成功返回 false</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/C51813C0-1A70-43C2-9904-A34DB96EE26F.png" alt="cfb2330ae916543f626159ebbfeb4aea.png"></p><p>无锁：尝试获取锁。有锁：判断是否是当前线程获取了锁</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/353F2EF6-4909-4DC4-97B4-308B2F2D5413.png" alt="b2812a7ffaf51eed3bb36c411f024e2d.png"></p><h4 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS#addWaiter"></a>AQS#addWaiter</h4><p>如果 tryAcquire 方法获取锁失败后，会调用 addWaiter 将当前线程封装成 Node 添加到队尾。</p><p>如果队列不为空，尝试一次 CAS 添加对队尾。如果不成功，就调用 enq 方法自旋 CAS 添加到队列尾部</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/247CCDDA-5950-4769-B03F-4BDF87F9D118.png" alt="94da97d14eb4f5b88876b443a85bd147.png"></p><h4 id="流程总结-tryAcquire-gt-addWaiter"><a href="#流程总结-tryAcquire-gt-addWaiter" class="headerlink" title="流程总结 tryAcquire -&gt; addWaiter"></a>流程总结 tryAcquire -&gt; addWaiter</h4><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/8832D866-6264-40BF-8B5F-C7CCC39DD3A4.png" alt="d706ed505dbffc01c27cddc83a5e46b4.png"></p><h4 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS#acquireQueued"></a>AQS#acquireQueued</h4><p>如果前置节点是头结点，就尝试获取锁。否则将前置节点 waitStatus 改为 SIGNAL，然后将当前线程挂起</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/8A25196E-2E38-4635-AEF1-24401A3ABC89.png" alt="2f9dcc6b6d65837b462638b26989fc30.png"></p><h3 id="ReentrantLock-unlock-源码分析"><a href="#ReentrantLock-unlock-源码分析" class="headerlink" title="ReentrantLock#unlock 源码分析"></a>ReentrantLock#unlock 源码分析</h3><p>释放锁，会唤醒后续的节点，唤醒的节点会在 acquireQueued 方法中继续运行（哪里跌倒，哪里爬起）</p><h3 id="AQS-疑难解惑"><a href="#AQS-疑难解惑" class="headerlink" title="AQS 疑难解惑"></a>AQS 疑难解惑</h3><h4 id="enq-方法返回前置节点"><a href="#enq-方法返回前置节点" class="headerlink" title="enq 方法返回前置节点"></a>enq 方法返回前置节点</h4><p>enq 方法，自旋将 node 添加到队列尾部，返回的是 node 的前置节点</p><h4 id="AQS-需要一个虚拟的-head-节点"><a href="#AQS-需要一个虚拟的-head-节点" class="headerlink" title="AQS 需要一个虚拟的 head 节点"></a>AQS 需要一个虚拟的 head 节点</h4><p>线程挂起，需要将前置节点 ws 改为 SIGNAL 状态，这样才能保证自己被唤醒。虚拟的 head 节点就是为了处理这样的边界情况，保证第一个包含了线程的节点能够被唤醒。</p><h4 id="AQS-通过判断前置节点-waitStatus-来唤醒节点线程，为什么？"><a href="#AQS-通过判断前置节点-waitStatus-来唤醒节点线程，为什么？" class="headerlink" title="AQS 通过判断前置节点 waitStatus 来唤醒节点线程，为什么？"></a>AQS 通过判断前置节点 waitStatus 来唤醒节点线程，为什么？</h4><p>保证状态一致性，防止重复唤醒</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/stateis0/p/9062045.html">https://www.cnblogs.com/stateis0/p/9062045.html</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html#_label0">https://www.cnblogs.com/dennyzhangdd/p/7218510.html#_label0</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/disrupt.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/disrupt.html" class="post-title-link" itemprop="url">disrupt 实现原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-06-23 21:59:08" itemprop="dateCreated datePublished" datetime="2019-06-23T21:59:08+08:00">2019-06-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaWeb/" itemprop="url" rel="index"><span itemprop="name">javaWeb</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、Disruptor-简介"><a href="#一、Disruptor-简介" class="headerlink" title="一、Disruptor 简介"></a>一、Disruptor 简介</h2><p>线程间通讯框架，实现多线程共享数据。是一个高性能无锁队列，由英国外汇交易公司 LMAX 开发。</p><p>性能测试：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></p><h2 id="二、Disruptor-为什么这么快"><a href="#二、Disruptor-为什么这么快" class="headerlink" title="二、Disruptor 为什么这么快"></a>二、Disruptor 为什么这么快</h2><h3 id="2-1-无锁操作"><a href="#2-1-无锁操作" class="headerlink" title="2.1 无锁操作"></a>2.1 无锁操作</h3><p>生产数据消费数据都是通过申请序列，申请成功后才可以继续操作。而申请序列的操作时通过 CAS + LockSupport 完成的。</p><h3 id="2-2-消除伪共享"><a href="#2-2-消除伪共享" class="headerlink" title="2.2 消除伪共享"></a>2.2 消除伪共享</h3><p>通过填充数据方式来实现消除伪共享</p><h4 id="2-2-1-什么是伪共享"><a href="#2-2-1-什么是伪共享" class="headerlink" title="2.2.1 什么是伪共享"></a>2.2.1 什么是伪共享</h4><p>cpu 三级缓存架构如下</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor.png" alt="cpu 三级缓存"></p><p>thread1 和 thread2 读取数据会覆盖 cpu cache line</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor1.png" alt="伪共享"></p><h4 id="2-2-2-通过数据填充消除伪共享"><a href="#2-2-2-通过数据填充消除伪共享" class="headerlink" title="2.2.2 通过数据填充消除伪共享"></a>2.2.2 通过数据填充消除伪共享</h4><p>通过填充数据，使数据长度恰好等于一个缓存行长度（64 字节 or 128 字节），这样数据占据整个缓存行，就不会被别的数据覆盖。</p><p>Disruptor 中的 Sequence 序列号对象，通过先后数据填充，变为 128 个字节，实现伪共享消除的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LhsPadding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">LhsPadding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RhsPadding</span> <span class="keyword">extends</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> <span class="keyword">extends</span> <span class="title">RhsPadding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INITIAL_VALUE = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE_OFFSET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前置p1<del>p7，后置p9</del>p15填充缓存行，防止缓冲行共享。一般的处理器架构缓存行是64字节，但是有个处理器架构是128字节，所以采用前后填充，能够实现在所有处理器上消除伪共享。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor2.png" alt="缓存行"></p><h3 id="2-3-环形-buffer"><a href="#2-3-环形-buffer" class="headerlink" title="2.3 环形 buffer"></a>2.3 环形 buffer</h3><p>内部采用数组存储数据，充分利用内存局部性原理。</p><p>只使用一个指针来表示可用数据，没有头尾指针。消除头尾指针竞争。各个生产者消费者只需要申请自己的序列号，就可以进行操作了。不存在竞争同一资源。</p><p>bufferSize 是 2 的 n 次幂，通过 sequence &amp; (2^n -1) 来计算索引。</p><p>通过数据覆盖，不需要删除数据，无需 GC。</p><h2 id="三、Disruptor-如何工作"><a href="#三、Disruptor-如何工作" class="headerlink" title="三、Disruptor 如何工作"></a>三、Disruptor 如何工作</h2><h3 id="3-1-消费者端"><a href="#3-1-消费者端" class="headerlink" title="3.1 消费者端"></a>3.1 消费者端</h3><p>每个消费者都对应一个 ConsumerBarrier，消费者通过 ConsumerBarrier 与 Disruptor 交互。消费者通过 ConsumerBarrier 获取下一个可以消费的序列号，然后开始消费。比如消费者 A 当前消费的序列号是8，通过 ConsumerBarrier 获取下一个可消费的序列号是 12，那么消费者 A 可以批量消费序列号 9，10，11，12 的数据。</p><p><strong>消费者消费数据步骤：1.获取序列号，2.消费数据</strong></p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor3.png" alt="消费者消费步骤"></p><h3 id="3-2-生产者端"><a href="#3-2-生产者端" class="headerlink" title="3.2 生产者端"></a>3.2 生产者端</h3><p>多个生产者对应一个 Sequencer，也就是说多个生产者共用一个序列号。</p><p><strong>生产者生产数据步骤：1.申请序列号，2.填充数据，3.发布</strong></p><p>生产者 A 和生产者 B <strong>同时生产</strong>数据，如下图：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor4.png" alt="生产者1"></p><p>生产者 A <strong>讯轮阻塞</strong> 等待消费者 A，如下图：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor5.png" alt="生产者2"></p><p>消费者 A <strong>轮训非阻塞</strong> 等待生产者 B，如下图：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/disruptor6.png" alt="生产者3"></p><h2 id="四、源码导读"><a href="#四、源码导读" class="headerlink" title="四、源码导读"></a>四、源码导读</h2><h3 id="4-1-核心类"><a href="#4-1-核心类" class="headerlink" title="4.1 核心类"></a>4.1 核心类</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LMAX-Exchange/disruptor/wiki/Introduction">https://github.com/LMAX-Exchange/disruptor/wiki/Introduction</a></p><p>ringbuff上有指针，每个消费者都维护自己的一个指针，生产者共用一个指针。指针是由 Sequencer类来控制的假设buffsize=8，如果消费者在消费id7，生产者将生产id15（15-buffsize=7），是同一个位置，生产者阻塞，如果生产者在生产id7，消费者在消费id7，消费者阻塞</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/162762019.png" alt="流程图"></p><h3 id="4-2-生产者端"><a href="#4-2-生产者端" class="headerlink" title="4.2 生产者端"></a>4.2 生产者端</h3><h4 id="4-2-1-申请序号"><a href="#4-2-1-申请序号" class="headerlink" title="4.2.1 申请序号"></a>4.2.1 申请序号</h4><p>调用 Sequencer#get ，直接看多生产者如果申请序号的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;n must be &gt; 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> current;</span><br><span class="line">  <span class="keyword">long</span> next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取当前发布序号</span></span><br><span class="line">    current = cursor.get();</span><br><span class="line">    next = current + n;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">long</span> wrapPoint = next - bufferSize;</span><br><span class="line">    <span class="comment">// gatingSequenceCache 这是 gatingSequence 的缓存，存入的是最小的消费者消费序列（有多个消费者）</span></span><br><span class="line">    <span class="keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();</span><br><span class="line">		<span class="comment">// 生产者要覆盖未被消费的数据（生产者超过消费者一圈了）</span></span><br><span class="line">    <span class="keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; current)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取最小的消费者序列</span></span><br><span class="line">      <span class="keyword">long</span> gatingSequence = Util.getMinimumSequence(gatingSequences, current);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)</span><br><span class="line">      &#123;</span><br><span class="line">        LockSupport.parkNanos(<span class="number">1</span>); <span class="comment">// TODO, should we spin based on the wait strategy?</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">			<span class="comment">// 更新缓存</span></span><br><span class="line">      gatingSequenceCache.set(gatingSequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-写入数据"><a href="#4-2-2-写入数据" class="headerlink" title="4.2.2 写入数据"></a>4.2.2 写入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">long</span> sequence)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (E)entries[(<span class="keyword">int</span>)sequence &amp; indexMask];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// dosomething</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3发布"><a href="#4-2-3发布" class="headerlink" title="4.2.3发布"></a>4.2.3发布</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 将待发布的序列设为可用，这样消费者就可以消费这个序列了</span></span><br><span class="line">  setAvailable(sequence);</span><br><span class="line">  waitStrategy.signalAllWhenBlocking();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-消费者端"><a href="#4-3-消费者端" class="headerlink" title="4.3 消费者端"></a>4.3 消费者端</h3><p>Disruptor#start 启动，会在线程池里启动 EventProcessor，每个 EventHandler 对应一个 EventProcessor</p><p>BatchEventProcessor 是 EventProcessor 的实现类，run方法里会轮训，是否有 event 可以被消费，如果可以就调用 EventHandler#onEvent 方法，触发消费者事件。</p><p>重点看 BatchEventProcessor#run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 状态设为启动，是一个AtomicBoolean</span></span><br><span class="line">  <span class="keyword">if</span> (!running.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Thread is already running&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清除中断</span></span><br><span class="line">  sequenceBarrier.clearAlert();</span><br><span class="line">	<span class="comment">// 判断一下消费者是否实现了LifecycleAware ,如果实现了这个接口，那么此时会发送一个启动通知</span></span><br><span class="line">  notifyStart();</span><br><span class="line"></span><br><span class="line">  T event = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> nextSequence = sequence.get() + <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 获取最大可用的序号，表示在之前的都可以安全消费</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> availableSequence = sequenceBarrier.waitFor(nextSequence);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nextSequence &lt;= availableSequence)</span><br><span class="line">        &#123;</span><br><span class="line">          event = dataProvider.get(nextSequence);</span><br><span class="line">          eventHandler.onEvent(event, nextSequence, nextSequence == availableSequence);</span><br><span class="line">          nextSequence++;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 记录对应消费者消费到哪里</span></span><br><span class="line">        sequence.set(availableSequence);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (<span class="keyword">final</span> TimeoutException e)</span><br><span class="line">      &#123;</span><br><span class="line">        notifyTimeout(sequence.get());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (<span class="keyword">final</span> AlertException ex)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果任务停止，就退出</span></span><br><span class="line">        <span class="keyword">if</span> (!running.get())</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex)</span><br><span class="line">      &#123;</span><br><span class="line">        exceptionHandler.handleEventException(ex, nextSequence, event);</span><br><span class="line">        sequence.set(nextSequence);</span><br><span class="line">        nextSequence++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">    notifyShutdown();</span><br><span class="line">    <span class="comment">// 任务关闭</span></span><br><span class="line">    running.set(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者在消费时候，需要判断其最大可消费的序列号，这个最大可消费序列号是通过 SequenceBarrier#waitFor 方法来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">waitFor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> sequence)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> AlertException, InterruptedException, TimeoutException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    		<span class="comment">// 判断是否中断，如果中断就抛出异常，这样上层捕捉，就可以停止 BatchEventProcessor</span></span><br><span class="line">        checkAlert();</span><br><span class="line">				<span class="comment">// 根据不同的策略获取可用的序列</span></span><br><span class="line">        <span class="keyword">long</span> availableSequence = waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="keyword">this</span>);</span><br><span class="line">				<span class="comment">// 可用序列比申请的序列小，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (availableSequence &lt; sequence)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> availableSequence;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 如果是单生产者，直接返回 availableSequence；对于多生产者判断是否可用，不可用返回sequence-1</span></span><br><span class="line">        <span class="keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/LMAX-Exchange/disruptor">https://github.com/LMAX-Exchange/disruptor</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/caffeine.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/caffeine.html" class="post-title-link" itemprop="url">caffeine 缓存实现原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-05-12 21:04:31" itemprop="dateCreated datePublished" datetime="2019-05-12T21:04:31+08:00">2019-05-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaWeb/" itemprop="url" rel="index"><span itemprop="name">javaWeb</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>我们知道 HashMap 可以作为进程内缓存，他不受外部系统影响，速度快。但是他不能像分布式缓存那样能够实时刷新，且本地内存有限，需要限定 HashMap 的容量范围，这就涉及到缓存淘汰问题。为了解决本地缓存的这些问题，Guava Cache 应运而生，他提供了异步刷新和 LRU 淘汰策略。Guava Cache 功能虽然强大，但是只是对 LRU 的一层封装，在复杂的业务场景下，LRU 淘汰策略显得力不从心。为此基于 W-TinyLFU(LFU+LRU算法的变种) 淘汰策略的进程内缓存 —— Caffeine Cache 诞生了。</p><p>Caffeine 的设计实现来自于大量优秀的研究，SpringBoot2 和 Spring5 已经默认支持 Caffeine Cache 代替原来的 Guava Cache，足以见得 Caffeine Cache 的地位。</p><p>本文将试着探究 Guava Cache 和 Caffeine Cache 的实现原理，重点讲解 Caffeine Cache 相比于 Guava Cache 有哪些优秀的设计和改动。本文研究的 caffeine 版本是 2.7.0，guava 版本是 27.1-jre。</p><h2 id="二、缓存淘汰算法"><a href="#二、缓存淘汰算法" class="headerlink" title="二、缓存淘汰算法"></a>二、缓存淘汰算法</h2><p>因为本地内存非常有限，我们的进程内缓存必须是有界的，需要进行数据淘汰，将无效的数据驱逐。一个好的淘汰算法，决定了其命中率高低。下面会简单介绍一些常见的淘汰算法，以便于后续的深入讲解。</p><h3 id="2-1-LFU"><a href="#2-1-LFU" class="headerlink" title="2.1 LFU"></a>2.1 LFU</h3><p>LFU（Least Frequently Used，最近最不常用）根据数据的访问频率，淘汰掉最近访问频率最低的数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p><p>需要维护每个数据项的访问频率信息，每次访问都需要更新，这个开销是非常大的。</p><p>LFU 能够很好地应对偶发性、周期性的批量操作，不会造成缓存污染。但是对于突发性的热点事件，比如外卖中午时候访问量突增、微博爆出某明星糗事就是一个突发性热点事件。当事件结束后，可能没有啥访问量了，但是由于其极高的访问频率，导致其在未来很长一段时间内都不会被淘汰掉。</p><h3 id="2-2-LRU"><a href="#2-2-LRU" class="headerlink" title="2.2 LRU"></a>2.2 LRU</h3><p>LRU（Least recently used，最近最少使用）根据数据的访问记录，淘汰掉最近最少使用的数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”（时间局部性原理）。</p><p>需要用 queue 来保存访问记录，可以用 LinkedHashMap 来简单实现一个基于 LRU 算法的缓存。</p><p>当存在热点数据时，LRU的效率很好。但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><h3 id="2-3-TinyLFU"><a href="#2-3-TinyLFU" class="headerlink" title="2.3 TinyLFU"></a>2.3 TinyLFU</h3><p>TinyLFU 顾名思义，轻量级LFU，相比于 LFU 算法用更小的内存空间来记录访问频率。</p><p>TinyLFU 维护了近期访问记录的频率信息，不同于传统的 LFU 维护整个生命周期的访问记录，所以他可以很好地应对突发性的热点事件（超过一定时间，这些记录不再被维护）。这些访问记录会作为一个过滤器，当新加入的记录（New Item）访问频率高于将被淘汰的缓存记录（Cache Victim）时才会被替换。流程如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio7.svg?sanitize=true" alt="08c4cfb4641549d3fb651df6d21425c7.png"></p><p>尽管维护的是近期的访问记录，但仍然是非常昂贵的，TinyLFU 通过 Count-Min Sketch 算法来记录频率信息，它占用空间小且误报率低，关于 Count-Min Sketch 算法可以参考论文：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://dimacs.rutgers.edu/~graham/pubs/papers/cmsoft.pdf">pproximating Data with the Count-Min Data Structure</a></p><h3 id="2-4-W-TinyLFU"><a href="#2-4-W-TinyLFU" class="headerlink" title="2.4 W-TinyLFU"></a>2.4 W-TinyLFU</h3><p>W-TinyLFU 算法相比于 LRU 等算法，具有更高的命中率。下图是一个运行了 ERP 应用的数据库服务中各种算法的命中率，实验数据来源于 ARC 算法作者，更多场景的性能测试参见：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ben-manes/caffeine/wiki/Efficiency">官网</a></p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/66CBD80A-A07E-48CC-8CA8-19FE4ED688FB.png" alt="fc0df0eba9c3b7485b30d498559d98ac.png"><br>（图片来源于：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ben-manes/caffeine/wiki/Efficiency%EF%BC%89">https://github.com/ben-manes/caffeine/wiki/Efficiency）</a></p><p>W-TinyLFU 算法是对 TinyLFU算法的优化，能够很好地解决一些稀疏的突发访问元素。在一些数目很少但突发访问量很大的场景下，TinyLFU将无法保存这类元素，因为它们无法在短时间内积累到足够高的频率，从而被过滤器过滤掉。W-TinyLFU 将新记录暂时放入 Window Cache 里面，只有通过 TinLFU 考察才能进入 Main Cache。大致流程如下图：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio8.svg?sanitize=true" alt="394b28c7e161703b4630108f894f9ece.png"></p><h2 id="三、缓存事务"><a href="#三、缓存事务" class="headerlink" title="三、缓存事务"></a>三、缓存事务</h2><p>为了实现缓存的过期策略，我们需要在访问数据的时候记录一系列信息，我们将该操作定义为<strong>缓存事务</strong>。</p><p>对于一个实现了写后过期的缓存，需要在其 put 操作时，记录 entry 的写时间，后续通过这个 entry 写时间来判断其是否过期。对于一个实现了读后过期的缓存，需要在其 get 操作时记录 entry 的最后访问时间，后续通过 entry 的最后访问时间来判断其是否过期。对于一个实现了 LFU 淘汰策略的缓存，需要在每次 get 操作时记录 entry 的访问次数，后续通过 entry 的访问次数来判断其是否淘汰。为了便于后续的表述，对于这种为实现缓存的过期淘汰策略而做的一系列额外操作，我们将其定义为<strong>缓存事务</strong>。</p><h2 id="四、guava-缓存"><a href="#四、guava-缓存" class="headerlink" title="四、guava 缓存"></a>四、guava 缓存</h2><p>guava 缓存提供了基于容量、时间、引用的过期策略。基于容量的实现是采用 LRU 算法。基于引用的实现是借助于 JVM GC，因为缓存的key被封装在WeakReference引用内，缓存的Value被封装在WeakReference或SoftReference引用内。</p><p>为了减少读写缓存的并发问题，参考了 JDK1.7 版本的 ConcurrentHashMap，实现了分段锁机制来减少锁粒度。然而分段锁机制不是非常好的方案，JDK1.8 已经取消了 ConcurrentHashMap 的分段锁，采用的 CAS + synchronized，他只锁住数组的单个元素。关于 ConcurrentHashMap 在 JDK1.8 中的改进，这里不再展开。</p><p>采用 LRU 过期策略，每个 Segment 维护三个 queue，writeQueue 、 accessQueue和recencyQueue。其中 recencyQueue 是记录 get 操作命中的，accessQueue 是记录 get 操作未命中的。recencyQueue 是无锁操作，需要保证线程安全。 值得注意的是，在高并发下，queue的竞争是比较激烈，guava 是在 每个 put/get 操作时记录到对应的 queue，这样增加了用户端的耗时。</p><p>过期策略是在访问数据的时候，判断是否过期。这样做好处是不需要后台线程定期扫描，但增加了耗时和内存损耗（本该过期的数据没有及时过期）。</p><h3 id="4-1-Guava-缓存的执行流程"><a href="#4-1-Guava-缓存的执行流程" class="headerlink" title="4.1 Guava 缓存的执行流程"></a>4.1 Guava 缓存的执行流程</h3><p>guava 的事务操作是在读取缓存时一起执行的，读取缓存操作流程如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio9.svg?sanitize=true" alt="ec637600e0c6833c9b23076f48e3487a.png"></p><p>事务处理在读取缓存时同步进行，这样的好处是不需要后台线程定期扫描处理事务，保证数据的实时性，但会增加一定的耗时。</p><h3 id="4-2-Guava-缓存中的事务处理"><a href="#4-2-Guava-缓存中的事务处理" class="headerlink" title="4.2 Guava 缓存中的事务处理"></a>4.2 Guava 缓存中的事务处理</h3><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio10.svg?sanitize=true" alt="bbd76bb898c0e572a12de5d4ba0c2c37.png"></p><p>采用 LRU 过期策略，每个 Segment 维护三个 queue，writeQueue 、 accessQueue和recencyQueue。用来实现不同情况的 LRU 淘汰策略。其中 recencyQueue 是<strong>记录 get 命中操作的</strong>，这是个多线程操作，Guava 通过线程安全的 recencyQueue 来记录，然后通过单线程批量 recencyQueue 将访问记录添加到非线程安全的 accessQueue，可以看出 recencyQueue <strong>起到缓冲的作用</strong>。 正因为 recencyQueue 是线程安全的，在 get 操作时又增加了并发竞争耗时（将 Entry 添加到 recencyQueue）。</p><h2 id="五、caffeine-缓存"><a href="#五、caffeine-缓存" class="headerlink" title="五、caffeine 缓存"></a>五、caffeine 缓存</h2><p>相比于 Guava 缓存，采用了更加先进的过期策略 W-TinyLFU，通过 RingBuffer 缓存事务，并用后台进程批量处理事务。Caffeine 直接采用的是 ConcurrentHashMap，要知道 ConcurrentHashMap 在 JDK1.8 是有非常大的性能提升的。</p><p>简单讲，Caffeine 是对 ConcurrentHashMap 进行封装，采用缓冲和后台线程批量处理事务，Caffeine 官方称其并发性能近视等于 ConcurrentHashMap。</p><p>Caffeine 官方做了性能测试，其中 6 线程读 2 线程写吞吐量如下图：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/7B9BF947-6252-46E6-B0B5-77DE828AD6FE.png" alt="f9487f4ff3617d4f5c8c80f3186cf8e8.png"><br>（图片来源于：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ben-manes/caffeine/wiki/Benchmarks%EF%BC%89">https://github.com/ben-manes/caffeine/wiki/Benchmarks）</a></p><p>可以看到 Caffeine 缓存吞吐量远超 Guava 缓存，其余场景性能测试详见：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ben-manes/caffeine/wiki/Benchmarks">官网</a></p><h3 id="5-1-基于-W-TinyLFU"><a href="#5-1-基于-W-TinyLFU" class="headerlink" title="5.1 基于 W-TinyLFU"></a>5.1 基于 W-TinyLFU</h3><p>前面已经提到了 W-TinyLFU 算法，Caffeine 采用 W-TinyLFU 算法来实现其淘汰策略。Caffeine 内部维护了三个 queue，分别为：</p><ul><li>access order queue，实现读后过期</li><li>write order queue，实现写后过期</li><li>Hierarchical TimerWheel，实现定时过期</li></ul><p>在大多数情况下，读操作远比写操作多，因此 Caffeine 为了提高读并发能力，采用分段策略，将 access order queue 分为三种，分别是 WindowDeque、ProbationDeque、ProtectedDeque。这三者关系如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio11.svg?sanitize=true" alt="d5044eb799b261357b0a4ce8f762989b.png"></p><p>结合 W-TinyLFU 算法，可以得出记录从产生到淘汰的整个流程：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/57F8E049-C5CE-4538-A6C0-9F9D071D7BF7.png" alt="f575ccd5c3ee35ca692a41ee0faa5505.png"><br>（图片来源于：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html%EF%BC%89">http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html）</a></p><p>新的记录会进入第一个 LRU，这个在 Caffeine 里是 WindowDeque。之后通过过滤器过滤，过滤器通过访问频率来实现过滤，只有高于将要淘汰数据的使用频率才能进入缓存。这个频率信息维护就是前面提到的 Count-Min Sketch 算法来实现的，具体是 FrequencySketch 类。</p><h4 id="5-1-1-过期策略"><a href="#5-1-1-过期策略" class="headerlink" title="5.1.1 过期策略"></a>5.1.1 过期策略</h4><p>Caffeine 采用统一的过期时间，这样可以实现 O(1) 复杂度往队列里添加和取出记录。对于写后过期，维护一个写入顺序队列，对于读后过期，维护一个读顺序队列。值得注意的是，这些操作都是单线程异步执行的。</p><h3 id="5-2-执行流程"><a href="#5-2-执行流程" class="headerlink" title="5.2 执行流程"></a>5.2 执行流程</h3><p>与 Guava 最大的不同就是，Caffeine 在读取缓存操作时，将<strong>事务提交到缓存异步批量处理</strong>，大致处理流程如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio12.svg?sanitize=true" alt="a90c9c637a6b76cf46f13d01815bcd86.png"></p><h3 id="5-3-缓存区"><a href="#5-3-缓存区" class="headerlink" title="5.3 缓存区"></a>5.3 缓存区</h3><h4 id="5-3-1-readBuffer"><a href="#5-3-1-readBuffer" class="headerlink" title="5.3.1 readBuffer"></a>5.3.1 readBuffer</h4><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio13.svg?sanitize=true" alt="36ba91e8ba3b79918b10cdf7b9d17082.png"></p><p>采用RingBuffer，有损。为了进一步减少读并发，采用多个 RingBuffer（striped ring buffer 条带环形缓冲），通过线程 id 哈希到对应的RingBuffer。环形缓存的一个显著特点是不需要进行 GC，直接通过覆盖过期数据。</p><p>当一个 RingBuffer 容量满载后，会触发异步的执行操作，而后续的对该 ring buffer 的写入会被丢弃，直到这个 ring buffer 可被使用，因此 readBuffer 记录读缓存事务是有损的。因为读记录是为了优化驱策策略，允许他有损。</p><h4 id="5-3-2-writeBuffer"><a href="#5-3-2-writeBuffer" class="headerlink" title="5.3.2 writeBuffer"></a>5.3.2 writeBuffer</h4><p>采用传统的有界队列 ArrayQueue，无损</p><h3 id="5-4-状态机"><a href="#5-4-状态机" class="headerlink" title="5.4 状态机"></a>5.4 状态机</h3><p>缓冲区和细粒度的写带来了单个数据项的操作乱序的竞态条件。插入、读取、更新、删除都可能被各种顺序的重放，如果这个策略控制的不合适，则可能引起悬垂索引。解决方案是通过状态机来定义单个数据项的生命周期。这类似于 AQS 中的原子类型变量 state。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio14.svg?sanitize=true" alt="7744cc0f1faa13cb71a53c2033fe495c.png"></p><h3 id="5-5-事务处理"><a href="#5-5-事务处理" class="headerlink" title="5.5 事务处理"></a>5.5 事务处理</h3><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio15.svg?sanitize=true" alt="4aa939e0c2bfc37f2463823eeeca80d7.png"></p><h3 id="5-6-caffeine-get-操作流程图"><a href="#5-6-caffeine-get-操作流程图" class="headerlink" title="5.6 caffeine get 操作流程图"></a>5.6 caffeine get 操作流程图</h3><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio16.svg?sanitize=true" alt="f07e7f28159908d5899cb36643be3c46.png"></p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio17.svg?sanitize=true" alt="4fe5bac0356b7e0baf8f181938b1bcde.png"></p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html">http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ben-manes/caffeine">https://github.com/ben-manes/caffeine</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://arxiv.org/pdf/1512.00727.pdf">TinyLFU: A Highly Eﬃcient Cache Admission Policy</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://dimacs.rutgers.edu/~graham/pubs/papers/cmsoft.pdf">Approximating Data with the Count-Min Data Structure</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000016091569">https://segmentfault.com/a/1190000016091569</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://chuansongme.com/n/2254051">https://chuansongme.com/n/2254051</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/protobuf-use.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/protobuf-use.html" class="post-title-link" itemprop="url">protobuf 安装使用</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-04-30 21:40:30" itemprop="dateCreated datePublished" datetime="2019-04-30T21:40:30+08:00">2019-04-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaWeb/" itemprop="url" rel="index"><span itemprop="name">javaWeb</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>官网下载 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></li><li>解压，cd 到目录下</li><li>./configure</li><li>make</li><li>make check</li><li>sudo make install</li><li>which protoc</li><li>protoc –version</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编写proto文件（idl文件）"><a href="#编写proto文件（idl文件）" class="headerlink" title="编写proto文件（idl文件）"></a>编写proto文件（idl文件）</h3><p>一个名为 Person.proto文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;; </span><br><span class="line">option java_package = &quot;org.serialization.protobuf.quickstart&quot;;   </span><br><span class="line">option java_outer_classname = &quot;PersonProtobuf&quot;;   </span><br><span class="line">message Person  &#123;   </span><br><span class="line">  int32 age = 1;</span><br><span class="line">  string name = 2;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>使用 protoc 编译器，将 proto 文件编译成 java 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --java_out=./ Person.proto</span><br></pre></td></tr></table></figure><h3 id="序列化调用"><a href="#序列化调用" class="headerlink" title="序列化调用"></a>序列化调用</h3><p>引入 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/singleton.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/singleton.html" class="post-title-link" itemprop="url">单例模式</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-04-13 20:43:22" itemprop="dateCreated datePublished" datetime="2019-04-13T20:43:22+08:00">2019-04-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h2><p>类加载立即初始化，绝对线程安全，不存在访问安全问题。Spring IOC 容器 ApplicationContext 就是一个饿汉式单例。</p><p>优点：没有任何加锁，执行效率高，用户体验好</p><p>缺点：类加载就初始化，浪费空间</p><p>简单实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 也可以放在静态代码块中 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton HUNGRY_SINGLETON = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h2><p>需要时才加载</p><h3 id="通过-double-check-实现："><a href="#通过-double-check-实现：" class="headerlink" title="通过 double-check 实现："></a>通过 double-check 实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要用 volatile 修饰保证可见性和重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyDoubleCheckSingleton lazy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1.分配内存给对象</span></span><br><span class="line">                    <span class="comment">// 2.初始化对象</span></span><br><span class="line">                    <span class="comment">// 3.lazy 指向该对象</span></span><br><span class="line">                    lazy = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通过静态内部类实现："><a href="#通过静态内部类实现：" class="headerlink" title="通过静态内部类实现："></a>通过静态内部类实现：</h3><p>double-check 方法需要加锁，对程序性能有一定影响，用静态内部类实现更好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhouxinghang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-05-16</span></span><br><span class="line"><span class="comment"> * 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。</span></span><br><span class="line"><span class="comment"> * 实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。</span></span><br><span class="line"><span class="comment"> * 直接调用静态内部类时，外部类不会加载。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * final 保证方法不被重写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.LAZY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazySingleton LAZY_SINGLETON = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式的破坏"><a href="#单例模式的破坏" class="headerlink" title="单例模式的破坏"></a>单例模式的破坏</h2><h3 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h3><p>尽管构造方法加了 private 修饰，但是可以通过反射调用构造方法，因此对构造方法加以限制，重复创建直接抛出异常。</p><p>以上述 LazySingleton 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果通过反射来创建实例，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (LazySingletonHolder.LAZY_SINGLETON != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不允许创建多个不同实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h3><p>在序列化操作时，反序列化后的对象会重新分配内存空间，即重新创建，如果目标是单例对象，就会破坏单例模式。</p><p>对此，我们只需要增加 readResolve() 方法即可。以上述 LazySingleton 为例，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果通过反射来创建实例，就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (LazySingletonHolder.LAZY_SINGLETON != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不允许创建多个不同实例&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * final 保证方法不被重写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.LAZY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保证反序列化还是原对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazySingletonHolder.LAZY_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingletonHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazySingleton LAZY_SINGLETON = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么，需要看 JDK 序列化源码。ObjectInputStream 类的 readObject() -&gt; readObject0() -&gt; readOrdinaryObject() -&gt; invokeReadResolve()。invokeReadResolve 代码如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/71BF431A-33F0-4C49-A683-69AF7B27BDFE.png" alt="invokeReadResolve"></p><p>而 readResolveMethod 是在在私有方法 ObjectStreamClass() 中赋值的，代码如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/2143B7C0-E237-45EB-8D0D-FA667EC34717.png" alt="readResolveMethod"></p><p>可见的，如果被序列化的类定义了 readResolve() 方法，就会调用该方法实现反序列化。</p><p>增加 readResolve() 方法可以防止单例模式被破坏，但是在 readOrdinaryObject() 方法中还是会创建一个新对象的，只不过返回的是readResolve() 方法返回值。具体代码如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/351EE59B-F579-4B54-BE81-50C017D19F31.png" alt="创建一个新对象"></p><p>注册式单例可以避免这个问题</p><h2 id="注册式单例"><a href="#注册式单例" class="headerlink" title="注册式单例"></a>注册式单例</h2><p>注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标 识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。枚举单例也是《Effective Java》书中推荐的一种单例实现写法</p><h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Object date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译发现枚举类是通过静态代码块实现的饿汉式单例模式，反编译代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    INSTANCE = <span class="keyword">new</span> EnumSingleton(<span class="string">&quot;INSTANCE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    $VALUES = (<span class="keyword">new</span> EnumSingleton[] &#123;</span><br><span class="line">        INSTANCE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举缓存既不会被序列化破坏，也不会被反射破坏。</p><p>对于序列化，在 ObjectInputStream 类中 readEnum() 方法里，发现枚举类型是通过类名和 Class 对象类找到唯一的枚举对象，代码如下：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/11AC67F5-4A3E-427F-A758-9C7AA9A20444.png" alt="readEnum"></p><p>对于反射，Constructor 类中的 newInstance() 方法对于枚举类，直接抛出异常：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/9286BD38-C4BA-468A-A523-B6EAD2569951.png" alt="newInstance"></p><h3 id="容器缓存单例"><a href="#容器缓存单例" class="headerlink" title="容器缓存单例"></a>容器缓存单例</h3><p>可以看看 Spring 容器式单例实现：</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/31EC471D-8239-49AC-88B9-BA5C538D97D7.png" alt="Spring容器"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/mac-NTFS.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/mac-NTFS.html" class="post-title-link" itemprop="url">Mac 实现 NTFS 格式硬盘读写</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-04-13 19:32:59" itemprop="dateCreated datePublished" datetime="2019-04-13T19:32:59+08:00">2019-04-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">计算机操作</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>Mac本身是支持NTFS写入的，只是NTFS是微软开发，由于版权和一些技术细节原因，苹果不愿公开说自己支持NTFS写入，也是有自己以后可能不支持NTFS写入的考量</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>挂载上你的NTFS硬盘，查看硬盘名称</li><li>编辑/etc/fstab文件，使其支持NTFS写入</li><li>将/Volumes中的NTFS磁盘快捷方式到Finder</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><ol><li>插上硬盘后，查看你的硬盘名称，这里假设名称是AngleDisk</li><li>打开Applications的Terminal, 你也可以直接spotlight输入terminal打开</li><li>在终端输入sudo nano /etc/fstab 敲击回车</li><li>现在你看到了一个编辑界面，输入LABEL=AngleDisk none ntfs rw,auto,nobrowse后，敲击回车，再Ctrl+X，再敲击Y，再敲击回车</li><li>此时，退出你的移动硬盘，再重新插入，你会发现磁盘没有显示在桌面或是Finder之前出现的地方，别慌</li><li>打开Finder，Command+Shift+G，输入框中输入/Volumes，回车，你就可以看到你的磁盘啦！是可以读写的哟，Enjoy</li><li>方便起见，你可以直接把磁盘拖到Finder侧边栏中，这样下次使用就不用进入到/Volumes目录打开le</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/19571334">https://www.zhihu.com/question/19571334</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/docker-base.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/docker-base.html" class="post-title-link" itemprop="url">docker基础</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-04-09 20:59:33" itemprop="dateCreated datePublished" datetime="2019-04-09T20:59:33+08:00">2019-04-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javaWeb/" itemprop="url" rel="index"><span itemprop="name">javaWeb</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h2><h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h3><p>Docker 是 dotCloud 公司创立，go 语言编写，基于 Ubuntu 开发。基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于<strong>操作系统层面的虚拟化技术</strong>。隔离的进程独立于宿主和隔离的其他进程，也其曾为容器。</p><p>传统的虚拟机技术是虚拟一套硬件出来，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。而容器是直接运行在宿主机的内核，没有进行硬件虚拟。因此容器比传统虚拟机更为轻便。</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/ECE81376-BCEF-4910-9912-C25DED99496E.png" alt="虚拟机架构"></p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/08B03E00-B63F-48C3-874B-A9BB84CF7339.png" alt="docker 架构"></p><h3 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h3><h4 id="更高效利用系统资源"><a href="#更高效利用系统资源" class="headerlink" title="更高效利用系统资源"></a>更高效利用系统资源</h4><p>不需要硬件虚拟化，不需要运行完整 OS</p><h4 id="更快速的启动时间"><a href="#更快速的启动时间" class="headerlink" title="更快速的启动时间"></a>更快速的启动时间</h4><p>直接运行于宿主内核，做到秒级、甚至毫秒级启动</p><h4 id="一致的运行环境"><a href="#一致的运行环境" class="headerlink" title="一致的运行环境"></a>一致的运行环境</h4><p>提供了除内核外完整的运行时环境</p><h4 id="高效部署扩容"><a href="#高效部署扩容" class="headerlink" title="高效部署扩容"></a>高效部署扩容</h4><h4 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h4><table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为 <code>MB</code></td><td align="left">一般为 <code>GB</code></td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般几十个</td></tr></tbody></table><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>docker 采用 C/S 架构，Client 通过结构与 Server 进程通信实现容器的构建，运行和发布</p><p>Client 和 Server 可以运行在同一台机器，也可以通过跨主机实现远程通信</p><p><img src="https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/8FC69242-461F-4292-9D12-6E427DABE064.png" alt="docker 操作流程"></p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>镜像（Images）</td><td>用于创建 Docker 容器的模板</td></tr><tr><td>容器（Container）</td><td>独立运行的一个或一组应用</td></tr><tr><td>客户端（Client）</td><td>通过命令行或其他工具调用 Docker API</td></tr><tr><td>主机（Host）</td><td>一个宿主机用于执行 Docker 守护进程和容器</td></tr><tr><td>注册服务器（Registry）</td><td>用于保存镜像，类似于 git 厂库。Docker Hub(<a target="_blank" rel="noopener external nofollow noreferrer" href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td></tr></tbody></table><h3 id="镜像-image"><a href="#镜像-image" class="headerlink" title="镜像 image"></a>镜像 image</h3><p>操作系统分为内核和用户控件，对于 Linux 而言，内核启动后，会挂载 root 文件系统为其用户空间提供支持。而 Docker Image，就相当于一个 root 文件系统。</p><p>Docker Image 是一个特殊的文件系统，包好了提供容器运行所需的程序、库、资源、配置等文件外，还包括一些配置参数信息（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建后不会改变。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>Docker Image 不是 ISO 那样的打包文件，它采用 Union FS 技术，将其设计为分层存储的架构。后一层依赖于前一层，如果需要 update 只需要创建一个新的层。这有点类似于 git 版本管理，每一层就是一个 git commit。</p><h3 id="容器-container"><a href="#容器-container" class="headerlink" title="容器 container"></a>容器 container</h3><p>镜像和容器就像面向对象程序中的类和实例对象。镜像是静态定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器 Container 实质是进程，与宿主进程不同，容器进程运行于属于自己独立的 <strong>namespace</strong>。因此容器拥有自己独立的 root 文件系统、网络配置、进程空间甚至自己的用户 ID 空间。</p><p>每个容器运行时，以镜像为基础层，在其上创建一个容器的存储层，为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。容器存储层的生命周期和容器一致。容器存储层的数据也会随着容器的删除而删除。</p><p>按照 Docker 最佳实践要求，容器不应该像其容器存储层写入任务数据，容器存储层要<strong>保持无状态化</strong>。所有文件的写入都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发起读写，其性能和稳定性更高。</p><p>使用数据卷，容器删除或重新运行，数据不会丢失。</p><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p><strong>命名空间</strong>是 Linux kernel 的功能，实现一个进程集合只能访问一个资源集合，实现资源和进程的分区，保证其相互独立。</p><p>命名空间是实现 Linux container 的基础。</p><h3 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库 repository"></a>仓库 repository</h3><p>Docker Repository 用于保存镜像，可以理解为代码控制中的代码仓库。Docker 仓库也分为公有和私有，公有是 Docker Hub</p><h3 id="注册服务器-Registry"><a href="#注册服务器-Registry" class="headerlink" title="注册服务器 Registry"></a>注册服务器 Registry</h3><p>集中存储分发镜像的服务，一个 Docker Registry 包含多个仓库 Repository，每个仓库包含多个<strong>标签 Tag</strong>，每个 标签对应一个镜像</p><h2 id="Docker-实现原理"><a href="#Docker-实现原理" class="headerlink" title="Docker 实现原理"></a>Docker 实现原理</h2><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><p>命名空间是 Linux 提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。</p><h3 id="控制组-cgroups"><a href="#控制组-cgroups" class="headerlink" title="控制组 cgroups"></a>控制组 cgroups</h3><p>命名空间无法提供物理资源的隔离，比如 CPU 和内存，Linux 的控制组能够为一组进程分配资源（CPU, memory, disk I/O, network, etc.）</p><h3 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h3><p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p><h2 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h2><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a>docker version</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:39 2019</span><br><span class="line"> OS/Arch:           darwin/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a>docker info</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Supports d_type: true</span><br><span class="line"> Native Overlay Diff: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: local</span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 9754871865f7fe2f4e74d43e2fc7ccd237edcbce</span><br><span class="line">runc version: 09c8266bf2fcf9519a651b04ae54c967b9ab86ec</span><br><span class="line">init version: fec3683</span><br><span class="line">Security Options:</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.9.125-linuxkit</span><br><span class="line">Operating System: Docker for Mac</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 4</span><br><span class="line">Total Memory: 1.952GiB</span><br><span class="line">Name: linuxkit-025000000001</span><br><span class="line">ID: TCUF:2IMR:QS25:QSA3:XWGV:NL6K:B5OF:B6PQ:6I2L:LJQY:XYOS:BC4F</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): true</span><br><span class="line"> File Descriptors: 24</span><br><span class="line"> Goroutines: 50</span><br><span class="line"> System Time: 2019-04-10T02:47:02.917656675Z</span><br><span class="line"> EventsListeners: 2</span><br><span class="line">HTTP Proxy: gateway.docker.internal:3128</span><br><span class="line">HTTPS Proxy: gateway.docker.internal:3129</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">Product License: Community Engine</span><br></pre></td></tr></table></figure><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>搜索镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search ubuntu12.10</span></span><br><span class="line">NAME                        DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">chug/ubuntu12.10x64         Ubuntu Quantal Quetzal 12.10 64bit  base ima…   0                                       </span><br><span class="line">chug/ubuntu12.10x32         Ubuntu Quantal Quetzal 12.10 32bit  base ima…   0                                       </span><br><span class="line">yuanzai/ubuntu12.10x64                                                      0                                       </span><br><span class="line">mirolin/ubuntu12.10_redis                                                   0                                       </span><br><span class="line">mirolin/ubuntu12.10                                                         0                                       </span><br><span class="line">marcgibbons/ubuntu12.10                                                     0                                       </span><br><span class="line">khovi/ubuntu12.10                                                           0                                    </span><br></pre></td></tr></table></figure><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">898c46f3b1a1: Pull complete </span><br><span class="line">63366dfa0a50: Pull complete </span><br><span class="line">041d4cd74a92: Pull complete </span><br><span class="line">6e1bee0f8701: Pull complete </span><br><span class="line">Digest: sha256:017eef0b616011647b269b5c65826e2e2ebddbe5d1f8c1e56b3599fb14fabec8</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br></pre></td></tr></table></figure><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">898c46f3b1a1: Pull complete </span><br><span class="line">63366dfa0a50: Pull complete </span><br><span class="line">041d4cd74a92: Pull complete </span><br><span class="line">6e1bee0f8701: Pull complete </span><br><span class="line">Digest: sha256:017eef0b616011647b269b5c65826e2e2ebddbe5d1f8c1e56b3599fb14fabec8</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br></pre></td></tr></table></figure><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><h4 id="run-使用镜像创建容器"><a href="#run-使用镜像创建容器" class="headerlink" title="run 使用镜像创建容器"></a>run 使用镜像创建容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run ubuntu /bin/<span class="built_in">echo</span> hello world</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h4 id="run-创建容器，并交互式的运行"><a href="#run-创建容器，并交互式的运行" class="headerlink" title="run 创建容器，并交互式的运行"></a>run 创建容器，并交互式的运行</h4><p>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -i -t ubuntu /bin/bash</span></span><br><span class="line">root@5df6791cfcf7:/# </span><br><span class="line">root@5df6791cfcf7:/# ls</span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure><h4 id="run-d-守护态运行"><a href="#run-d-守护态运行" class="headerlink" title="run -d 守护态运行"></a>run -d 守护态运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zhouxinghang @ zhouxinghangdeMacBook-Pro <span class="keyword">in</span> ~/Documents/myworkspace [11:31:36]</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d ubuntu /bin/bash -c <span class="string">&quot;while true;do echo hello world;sleep 1;done&quot;</span></span></span><br><span class="line">95d8965f07977d237471a23fe128edf111f5c54cda85c9e3f4877c06dd60b12e</span><br></pre></td></tr></table></figure><p>docker logs 容器id 查看容器运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zhouxinghang @ zhouxinghangdeMacBook-Pro <span class="keyword">in</span> ~/Documents/myworkspace [11:34:40]</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker logs 95d8965f07977d237471a23fe128edf111f5c54cda85c9e3f4877c06dd60b12e</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h4 id="docker-run-创建容器，执行步骤"><a href="#docker-run-创建容器，执行步骤" class="headerlink" title="docker run 创建容器，执行步骤"></a>docker run 创建容器，执行步骤</h4><ul><li>检查本地是否存在指定镜像，若不存在就去仓库下载</li><li>利用镜像创建容器</li><li>分配文件系统，并在只读的镜像层外挂载一层读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完成，终止容器</li></ul><h3 id="docker-ps-查看容器"><a href="#docker-ps-查看容器" class="headerlink" title="docker ps 查看容器"></a>docker ps 查看容器</h3><p>-a 包括退出的历史容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">95d8965f0797        ubuntu              &quot;/bin/bash -c &#x27;while…&quot;   6 minutes ago       Exited (137) 10 seconds ago                           elegant_montalcini</span><br><span class="line">5cd7025b91b9        ubuntu              &quot;/bin/bash&quot;              12 minutes ago      Exited (130) About a minute ago                       stoic_yonath</span><br><span class="line">5df6791cfcf7        ubuntu              &quot;/bin/bash&quot;              40 minutes ago      Exited (127) 15 minutes ago                           nifty_kirch</span><br><span class="line">c48f8cdf8076        ubuntu              &quot;/bin/echo hello wor…&quot;   41 minutes ago      Exited (0) 41 minutes ago                             elastic_robinson</span><br></pre></td></tr></table></figure><h3 id="docker-attach-容器id-连接容器"><a href="#docker-attach-容器id-连接容器" class="headerlink" title="docker attach 容器id 连接容器"></a>docker attach 容器id 连接容器</h3><p>当多个窗口同时 attach 到同一个容器的时候，所有窗口都会<strong>同步显示</strong>。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker attach 5cd7025b91b9</span></span><br><span class="line">root@5cd7025b91b9:/var/log# </span><br></pre></td></tr></table></figure><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><ul><li>commit 将容器的状态保存为镜像</li><li>diff 查看容器内容变化</li><li>cp 拷贝文件</li><li>inspect 收集容器和镜像的底层信息</li><li>kill 停止容器主进程</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Linux_namespaces">https://en.wikipedia.org/wiki/Linux_namespaces</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Cgroups">https://en.wikipedia.org/wiki/Cgroups</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Aufs">https://en.wikipedia.org/wiki/Aufs</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://dockone.io/article/2941">http://dockone.io/article/2941</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/4ab37ad30bd2">https://www.jianshu.com/p/4ab37ad30bd2</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://zhouxinghang.github.io/jvm-options.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="zhouxinghang"><meta itemprop="description" content="行到水穷处，坐看云起时"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZBlog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/jvm-options.html" class="post-title-link" itemprop="url">jvm参数</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-04-06 21:15:55" itemprop="dateCreated datePublished" datetime="2019-04-06T21:15:55+08:00">2019-04-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="X-与-XX-的区别"><a href="#X-与-XX-的区别" class="headerlink" title="-X 与 -XX 的区别"></a>-X 与 -XX 的区别</h2><blockquote><p><strong>Standard options</strong> :Options that begin with - are Standard options are expected to be accepted by all JVM implementations and are stable between releases (though they can be deprecated).<br><strong>Non-standard options</strong> :Options that begin with -X are non-standard (not guaranteed to be supported on all JVM implementations), and are subject to change without notice in subsequent releases of the Java SDK.<br><strong>Developer options</strong> :Options that begin with -XX are developer options and often have specific system requirements for correct operation and may require privileged access to system configuration parameters; they are not recommended for casual use. These options are also subject to change without notice.</p></blockquote><h2 id="XX-参数格式"><a href="#XX-参数格式" class="headerlink" title="-XX 参数格式"></a>-XX 参数格式</h2><p>1）布尔类型 <code>-XX:+option (true) -XX:-option (false)</code></p><p><code>-XX:+DisableExplicitGC</code></p><p>2）数值类型 <code>-XX:option=number</code> 可以带单位 k,m,g(不区分大小写)</p><p><code>-XX:SurvivorRatio=8 -XX:MetaspaceSize=256M</code></p><p>3）字符类型 <code>-XX:option=String</code> 通常用来设置文件名、路径等</p><p><code>-XX:HeapDumpPath=./java_pid.hprof</code></p><h2 id="关于内存的参数设置"><a href="#关于内存的参数设置" class="headerlink" title="关于内存的参数设置"></a>关于内存的参数设置</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小，memory size</td></tr><tr><td>-Xmx</td><td>堆最大值，max memory size，一般和 -Xms 设置同样的大小</td></tr><tr><td>-Xmn</td><td>新生代大小，new memory size</td></tr><tr><td>-Xss</td><td>线程栈大小，stack size</td></tr><tr><td>-XX:PermSize=256m</td><td>永生代初始大小，JDK 8无效，JDK8 将永生代移入到 metaspace</td></tr><tr><td>-XX:MaxPermSize=512m</td><td>永生代最大值，JDK 8无效</td></tr><tr><td>-XX:MaxMetaspaceSize=512m</td><td>元空间初始化大小，JDK 8</td></tr><tr><td>-XX:newRatio=2</td><td>默认是2，新生代站1/3</td></tr><tr><td>-XX:Survivor=8</td><td>默认是8，两个 Survivor 共占用 2/10</td></tr><tr><td>-XX:NewSize</td><td>新生代初始化大小，一般和 -XX:MaxNewSize 设置同样大小，避免新生代内存伸缩</td></tr><tr><td>-XX:MaxNewSize</td><td>新生代最大值</td></tr><tr><td>-XX:InitialCodeCacheSize=128m</td><td>“代码缓存”大小，“代码缓存”用来存储方法编译生成的本地代码</td></tr></tbody></table><h3 id="jvm-设置新生代大小"><a href="#jvm-设置新生代大小" class="headerlink" title="jvm 设置新生代大小"></a>jvm 设置新生代大小</h3><p>jvm 设置新生代大小有很多组参数，大概分为三组：</p><ul><li><code>-XX:NewSize=1024m</code> 和 <code>-XX:MaxNewSize=1024m</code></li><li><code>-Xmn1024m</code></li><li><code>-XX:NewRatio=2</code> （假设Heap总共是3G）</li></ul><p>在 JDK 4 之后，使用 <code>-Xmn=1024m</code>，相当于同时设置 <code>-XX:NewSize=1024m</code> 和 <code>-XX:MaxNewSize=1024m</code>，<strong>推荐使用 -Xmn</strong></p><h2 id="关于-GC-日志相关参数"><a href="#关于-GC-日志相关参数" class="headerlink" title="关于 GC 日志相关参数"></a>关于 GC 日志相关参数</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>打印GC日志</td></tr><tr><td>-XX:+PrintGCDetails</td><td>打印GC详细日志，包括-XX:+PrintGC</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>打印GC时间戳</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>打印GC时间戳，以日期为准</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>在运行GC的前后打印堆信息</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>新生代GC的时候，打印存活对象的年龄分布</td></tr><tr><td>-XX:HeapDumpPath=/opt/log/oomlogs</td><td>内存溢出时保存当时的内存快照</td></tr><tr><td>-+HeapDumpOnOutOfMemoryError</td><td>发生OOM时，保存dump内存快照</td></tr></tbody></table><h2 id="关于-GC-行为相关参数"><a href="#关于-GC-行为相关参数" class="headerlink" title="关于 GC 行为相关参数"></a>关于 GC 行为相关参数</h2><h3 id="CMS-相关参数"><a href="#CMS-相关参数" class="headerlink" title="CMS 相关参数"></a>CMS 相关参数</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-XX:+DisableExplicitGC</td><td>禁用显示调用，System.gc()将成为空调用</td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS收集器收集老年代，特点是低停顿，停顿少。吞吐量相对较低，适合短连接事务型系统</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=80</td><td>在默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，可以适当调高，实际应用中老年代增长不会太快</td></tr></tbody></table><h3 id="G1-相关参数"><a href="#G1-相关参数" class="headerlink" title="G1 相关参数"></a>G1 相关参数</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-XX:G1HeapRegionSize=n</td><td>设置Region大小，并非最终值</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>设置G1收集过程目标时间，默认值200ms，不是硬性条件</td></tr><tr><td>-XX:G1NewSizePercent</td><td>新生代最小值，默认值5%</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代最大值，默认值60%</td></tr><tr><td>-XX:ParallelGCThreads</td><td>STW期间，并行GC线程数</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发标记阶段，并行执行的线程数</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent</td><td>设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://eyesmore.iteye.com/blog/1530996">https://eyesmore.iteye.com/blog/1530996</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/questions/7871870/what-is-the-difference-between-x-params-and-xx-params-in-jvm">https://stackoverflow.com/questions/7871870/what-is-the-difference-between-x-params-and-xx-params-in-jvm</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">zhouxinghang</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>