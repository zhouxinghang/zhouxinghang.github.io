<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZBlog</title>
  <icon>https://tig.red/icon.png</icon>
  <subtitle>day day up</subtitle>
  <link href="https://tig.red/atom.xml" rel="self"/>
  
  <link href="https://tig.red/"/>
  <updated>2021-11-25T03:40:12.324Z</updated>
  <id>https://tig.red/</id>
  
  <author>
    <name>zhouxinghang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unix-sockets-and-tcp-ip-sockets</title>
    <link href="https://tig.red/unix-sockets-and-tcp-ip-sockets.html"/>
    <id>https://tig.red/unix-sockets-and-tcp-ip-sockets.html</id>
    <published>2021-11-25T02:50:33.000Z</published>
    <updated>2021-11-25T03:40:12.324Z</updated>
    
    
    <summary type="html">介绍 Unix sockets 和 TCP/IP sockets</summary>
    
    
    
    
    <category term="socket" scheme="https://tig.red/tags/socket/"/>
    
    <category term="tcp" scheme="https://tig.red/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>druid-vs-hive</title>
    <link href="https://tig.red/druid-vs-hive.html"/>
    <id>https://tig.red/druid-vs-hive.html</id>
    <published>2021-11-24T07:56:41.000Z</published>
    <updated>2021-11-25T01:31:37.710Z</updated>
    
    
    <summary type="html">介绍 druid hive 的使用场景，简述实现原理</summary>
    
    
    
    <category term="大数据" scheme="https://tig.red/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="druid" scheme="https://tig.red/tags/druid/"/>
    
    <category term="hive" scheme="https://tig.red/tags/hive/"/>
    
    <category term="bigdata" scheme="https://tig.red/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>hexo5-next8 配置</title>
    <link href="https://tig.red/hexo5-next8.html"/>
    <id>https://tig.red/hexo5-next8.html</id>
    <published>2021-11-23T05:09:23.000Z</published>
    <updated>2021-11-25T02:12:18.727Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;## 安装 hexo，需要 nodejs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 安装 next 主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-theme-next&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 初始化 next 配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## hexo5 推荐将主题配置文件放在根目录，命名为：_config.[name].yml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 下面两种任选一种&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp node_modules/hexo-theme-next/_config.yml _config.next.yml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cp themes/next/_config.yml _config.next.yml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://tig.red/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Http 407 问题排查</title>
    <link href="https://tig.red/http-407-fix.html"/>
    <id>https://tig.red/http-407-fix.html</id>
    <published>2019-07-25T11:08:25.000Z</published>
    <updated>2021-11-24T07:09:20.032Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近接一个新的代理平台出现了大量 Http 请求 407 的错误，主要是 HttpClient 的“延迟认证”导致的，排查原因记录下&lt;/p&gt;
&lt;h2 id=&quot;basic-认证&quot;&gt;&lt;a href=&quot;#basic-认证&quot; class=&quot;headerlink&quot; title=&quot;basic 认证&quot;&gt;&lt;/a&gt;basic 认证&lt;/h2&gt;&lt;p&gt;实现简单，但如果是 http 请求的话，信息会泄露，存在安全风险&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/5ac175baf265da239e4e3999&quot;&gt;https://juejin.im/entry/5ac175baf265da239e4e3999&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;认证流程&quot;&gt;&lt;a href=&quot;#认证流程&quot; class=&quot;headerlink&quot; title=&quot;认证流程&quot;&gt;&lt;/a&gt;认证流程&lt;/h2&gt;&lt;p&gt;client -&amp;gt; server：未携带认证信息&lt;br&gt;server -&amp;gt; client：返回407&lt;br&gt;client -&amp;gt; server：携带认证信息&lt;br&gt;server -&amp;gt; client：返回200&lt;/p&gt;
&lt;p&gt;注意这两步在代码层面是无感知的，只会收到最后的200。如果这个tcp连接已经建立，下次请求就会直接携带认证信息&lt;/p&gt;</summary>
    
    
    
    <category term="异常排查" scheme="https://tig.red/categories/%E5%BC%82%E5%B8%B8%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="Http" scheme="https://tig.red/tags/Http/"/>
    
    <category term="HttpClient" scheme="https://tig.red/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock 实现原理</title>
    <link href="https://tig.red/ReentrantLock.html"/>
    <id>https://tig.red/ReentrantLock.html</id>
    <published>2019-07-07T09:45:14.000Z</published>
    <updated>2021-11-24T07:10:33.270Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Lock-简介&quot;&gt;&lt;a href=&quot;#Lock-简介&quot; class=&quot;headerlink&quot; title=&quot;Lock 简介&quot;&gt;&lt;/a&gt;Lock 简介&lt;/h2&gt;&lt;p&gt;Lock 是 JDK1.5 之后提供的接口，它提供了和 synchronized 类似的同步功能，比 synchronized 更为灵活，能弥补 synchronized 在一些业务场景中的短板。&lt;/p&gt;
&lt;h2 id=&quot;Lock-的实现&quot;&gt;&lt;a href=&quot;#Lock-的实现&quot; class=&quot;headerlink&quot; title=&quot;Lock 的实现&quot;&gt;&lt;/a&gt;Lock 的实现&lt;/h2&gt;&lt;h3 id=&quot;ReentrantLock&quot;&gt;&lt;a href=&quot;#ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock&quot;&gt;&lt;/a&gt;ReentrantLock&lt;/h3&gt;&lt;p&gt;可重入，排他，公平/非公平&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/drawio18.svg?sanitize=true&quot; alt=&quot;656edd2a54b6e7e2d12eee8b5acf364c.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://tig.red/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="源码" scheme="https://tig.red/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="AQS" scheme="https://tig.red/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>disrupt 实现原理</title>
    <link href="https://tig.red/disrupt.html"/>
    <id>https://tig.red/disrupt.html</id>
    <published>2019-06-23T13:59:08.000Z</published>
    <updated>2021-11-24T07:10:56.730Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一、Disruptor-简介&quot;&gt;&lt;a href=&quot;#一、Disruptor-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Disruptor 简介&quot;&gt;&lt;/a&gt;一、Disruptor 简介&lt;/h2&gt;&lt;p&gt;线程间通讯框架，实现多线程共享数据。是一个高性能无锁队列，由英国外汇交易公司 LMAX 开发。&lt;/p&gt;
&lt;p&gt;性能测试：&lt;a href=&quot;https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results&quot;&gt;https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="javaWeb" scheme="https://tig.red/categories/javaWeb/"/>
    
    
    <category term="源码" scheme="https://tig.red/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="disruptor" scheme="https://tig.red/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>caffeine 缓存实现原理</title>
    <link href="https://tig.red/caffeine.html"/>
    <id>https://tig.red/caffeine.html</id>
    <published>2019-05-12T13:04:31.000Z</published>
    <updated>2021-11-24T07:10:55.059Z</updated>
    
    
    <summary type="html">Caffeine Cache 是与 Guava Cache 功能类似的进程缓存，性能比 Guava Cache 更好。本文主要介绍 Caffeine Cache 的实现原理</summary>
    
    
    
    <category term="javaWeb" scheme="https://tig.red/categories/javaWeb/"/>
    
    
    <category term="caffeine" scheme="https://tig.red/tags/caffeine/"/>
    
    <category term="源码" scheme="https://tig.red/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>protobuf 安装使用</title>
    <link href="https://tig.red/protobuf-use.html"/>
    <id>https://tig.red/protobuf-use.html</id>
    <published>2019-04-30T13:40:30.000Z</published>
    <updated>2021-11-24T07:10:21.934Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;官网下载 &lt;a href=&quot;https://github.com/protocolbuffers/protobuf/releases&quot;&gt;https://github.com/protocolbuffers/protobuf/releases&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压，cd 到目录下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;./configure&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;make&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;make check&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sudo make install&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;which protoc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;protoc –version&lt;/p&gt;</summary>
    
    
    
    <category term="javaWeb" scheme="https://tig.red/categories/javaWeb/"/>
    
    
    <category term="protobuf" scheme="https://tig.red/tags/protobuf/"/>
    
    <category term="序列化" scheme="https://tig.red/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://tig.red/singleton.html"/>
    <id>https://tig.red/singleton.html</id>
    <published>2019-04-13T12:43:22.000Z</published>
    <updated>2021-11-24T07:10:37.145Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;饿汉式单例&quot;&gt;&lt;a href=&quot;#饿汉式单例&quot; class=&quot;headerlink&quot; title=&quot;饿汉式单例&quot;&gt;&lt;/a&gt;饿汉式单例&lt;/h2&gt;&lt;p&gt;类加载立即初始化，绝对线程安全，不存在访问安全问题。Spring IOC 容器 ApplicationContext 就是一个饿汉式单例。&lt;/p&gt;
&lt;p&gt;优点：没有任何加锁，执行效率高，用户体验好&lt;/p&gt;
&lt;p&gt;缺点：类加载就初始化，浪费空间&lt;/p&gt;</summary>
    
    
    
    <category term="java基础" scheme="https://tig.red/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="源码" scheme="https://tig.red/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="设计模式" scheme="https://tig.red/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac 实现 NTFS 格式硬盘读写</title>
    <link href="https://tig.red/mac-NTFS.html"/>
    <id>https://tig.red/mac-NTFS.html</id>
    <published>2019-04-13T11:32:59.000Z</published>
    <updated>2021-11-24T07:09:59.794Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;p&gt;Mac本身是支持NTFS写入的，只是NTFS是微软开发，由于版权和一些技术细节原因，苹果不愿公开说自己支持NTFS写入，也是有自己以后可能不支持NTFS写入的考量&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作" scheme="https://tig.red/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="mac" scheme="https://tig.red/tags/mac/"/>
    
    <category term="ntfs" scheme="https://tig.red/tags/ntfs/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://tig.red/docker-base.html"/>
    <id>https://tig.red/docker-base.html</id>
    <published>2019-04-09T12:59:33.000Z</published>
    <updated>2021-11-24T07:10:58.744Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Docker-简介&quot;&gt;&lt;a href=&quot;#Docker-简介&quot; class=&quot;headerlink&quot; title=&quot;Docker 简介&quot;&gt;&lt;/a&gt;Docker 简介&lt;/h2&gt;&lt;h3 id=&quot;什么是-Docker&quot;&gt;&lt;a href=&quot;#什么是-Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Docker&quot;&gt;&lt;/a&gt;什么是 Docker&lt;/h3&gt;&lt;p&gt;Docker 是 dotCloud 公司创立，go 语言编写，基于 Ubuntu 开发。基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于&lt;strong&gt;操作系统层面的虚拟化技术&lt;/strong&gt;。隔离的进程独立于宿主和隔离的其他进程，也其曾为容器。&lt;/p&gt;</summary>
    
    
    
    <category term="javaWeb" scheme="https://tig.red/categories/javaWeb/"/>
    
    
    <category term="javaWeb" scheme="https://tig.red/tags/javaWeb/"/>
    
    <category term="docker" scheme="https://tig.red/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>jvm参数</title>
    <link href="https://tig.red/jvm-options.html"/>
    <id>https://tig.red/jvm-options.html</id>
    <published>2019-04-06T13:15:55.000Z</published>
    <updated>2021-11-24T07:09:56.190Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;X-与-XX-的区别&quot;&gt;&lt;a href=&quot;#X-与-XX-的区别&quot; class=&quot;headerlink&quot; title=&quot;-X 与 -XX 的区别&quot;&gt;&lt;/a&gt;-X 与 -XX 的区别&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Standard options&lt;/strong&gt; :Options that begin with - are Standard options are expected to be accepted by all JVM implementations and are stable between releases (though they can be deprecated).&lt;br&gt;&lt;strong&gt;Non-standard options&lt;/strong&gt; :Options that begin with -X are non-standard (not guaranteed to be supported on all JVM implementations), and are subject to change without notice in subsequent releases of the Java SDK.&lt;br&gt;&lt;strong&gt;Developer options&lt;/strong&gt; :Options that begin with -XX are developer options and often have specific system requirements for correct operation and may require privileged access to system configuration parameters; they are not recommended for casual use. These options are also subject to change without notice.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java基础" scheme="https://tig.red/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://tig.red/tags/java/"/>
    
    <category term="jvm" scheme="https://tig.red/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>nginx实现原理</title>
    <link href="https://tig.red/nginx-implement.html"/>
    <id>https://tig.red/nginx-implement.html</id>
    <published>2019-03-30T12:37:47.000Z</published>
    <updated>2021-11-24T07:10:14.214Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;简单理解-Nginx&quot;&gt;&lt;a href=&quot;#简单理解-Nginx&quot; class=&quot;headerlink&quot; title=&quot;简单理解 Nginx&quot;&gt;&lt;/a&gt;简单理解 Nginx&lt;/h2&gt;&lt;p&gt;nginx 是静态 web 服务器，意思是 engine x。并发量高，性能优越&lt;/p&gt;</summary>
    
    
    
    <category term="javaWeb" scheme="https://tig.red/categories/javaWeb/"/>
    
    
    <category term="nginx" scheme="https://tig.red/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://tig.red/threadLocal.html"/>
    <id>https://tig.red/threadLocal.html</id>
    <published>2019-03-20T12:22:41.000Z</published>
    <updated>2021-11-24T07:10:51.322Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;总结 ThreadLocal 实现原理，缺点，InheritableThreadLocal 原理，ThreadLocalRandom 中如何应用 ThreadLocal，Spring Bean 中如何 应用 ThreadLocal&lt;/p&gt;</summary>
    
    
    
    <category term="java进阶" scheme="https://tig.red/categories/java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="spring" scheme="https://tig.red/tags/spring/"/>
    
    <category term="threadlocal" scheme="https://tig.red/tags/threadlocal/"/>
    
  </entry>
  
  <entry>
    <title>java常量池</title>
    <link href="https://tig.red/java-constant-pool.html"/>
    <id>https://tig.red/java-constant-pool.html</id>
    <published>2019-03-13T11:46:20.000Z</published>
    <updated>2021-11-24T07:09:27.858Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;java 包括三种常量池，分别是 字符串常量池、Class 常量池（也叫常量池表）和运行时常量池。&lt;/p&gt;
&lt;h2 id=&quot;字符串常量池（String-Pool）&quot;&gt;&lt;a href=&quot;#字符串常量池（String-Pool）&quot; class=&quot;headerlink&quot; title=&quot;字符串常量池（String Pool）&quot;&gt;&lt;/a&gt;字符串常量池（String Pool）&lt;/h2&gt;&lt;p&gt;String Pool 是 JVM 实例全局共享的，而 Runtime Constant Pool 是每个类都有一个。&lt;/p&gt;
&lt;p&gt;JVM 用一个哈希表记录对常量池的引用。&lt;/p&gt;
&lt;p&gt;String Pool 在 JDK1.7 之前是存放在方法区中的，JDK1.7 移入到堆中。可以测试下往List中无限放入String，看jdk各个版本的异常信息。jdk6是PermGen Space内存溢出，jdk7和8都是Java heap space内存溢出。&lt;/p&gt;</summary>
    
    
    
    <category term="java基础" scheme="https://tig.red/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="jvm" scheme="https://tig.red/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>AQS相关</title>
    <link href="https://tig.red/AQS.html"/>
    <id>https://tig.red/AQS.html</id>
    <published>2019-03-12T03:13:14.000Z</published>
    <updated>2021-11-24T07:10:53.130Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;AQS-简单介绍&quot;&gt;&lt;a href=&quot;#AQS-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;AQS 简单介绍&quot;&gt;&lt;/a&gt;AQS 简单介绍&lt;/h2&gt;&lt;p&gt;AbstractQueuedSynchronizer，抽象同步队列。是实现同步的基础组件，并发包中的锁都是基于 AQS 实现。&lt;/p&gt;
&lt;p&gt;内部有一个 &lt;strong&gt;state 变量&lt;/strong&gt;，用于表示一些状态信息，这个状态信息具体由实现类决定，比如一个 ReentrantLock 类这个 state 就表示获取锁的次数。&lt;/p&gt;
&lt;p&gt;内部维持两个队列，&lt;strong&gt;Sync Queue&lt;/strong&gt; 和 &lt;strong&gt;Condition Queue&lt;/strong&gt;，Sync Queue 是一个双向 FIFO 链表，是锁的时候用到。而 Condition Queue 是条件队列，作为锁的等待条件时用到。&lt;/p&gt;
&lt;p&gt;这个类使用到了&lt;strong&gt;模板方法设计模式&lt;/strong&gt;：定义一个操作中算法的骨架，而将一些步骤的实现延迟到子类中。&lt;/p&gt;</summary>
    
    
    
    <category term="并发编程" scheme="https://tig.red/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="AQS" scheme="https://tig.red/tags/AQS/"/>
    
    <category term="锁" scheme="https://tig.red/tags/%E9%94%81/"/>
    
    <category term="源码分析" scheme="https://tig.red/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="Lock" scheme="https://tig.red/tags/Lock/"/>
    
    <category term="synchronized" scheme="https://tig.red/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>java中的锁</title>
    <link href="https://tig.red/java-lock.html"/>
    <id>https://tig.red/java-lock.html</id>
    <published>2019-03-05T06:24:30.000Z</published>
    <updated>2021-11-24T07:09:42.210Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;公平锁和非公平锁&quot;&gt;&lt;a href=&quot;#公平锁和非公平锁&quot; class=&quot;headerlink&quot; title=&quot;公平锁和非公平锁&quot;&gt;&lt;/a&gt;公平锁和非公平锁&lt;/h2&gt;&lt;p&gt;公平锁好处是等待锁的线程不会饿死，但整体效率较低。非公平锁好处是整体效率高一些，但是有些线程可能需要等待很久才能获取到锁。因为非公平锁是可以抢占的。 &lt;/p&gt;
&lt;p&gt;两者内部都维持一个 AQS 等待队列（FIFO），放置等待等待获取锁的线程。如果释放锁的时候，没有新的线程来获取锁，这时候就会从 AQS 队列头取出线程让其获取到锁。这时候公平锁和非公平锁是一样的。如果释放锁的时候，刚好有新的线程来获取锁，非公平锁就会将锁分配给这个新的线程，这就是&lt;strong&gt;非公平锁的抢占式&lt;/strong&gt;。因为非公平锁中新来的线程有一定几率不会被挂起，&lt;strong&gt;减少了整体线程挂起的几率&lt;/strong&gt;，所以非公平锁性能高于公平锁。 &lt;/p&gt;
&lt;p&gt;公平锁可以使用new ReentrantLock(true)实现。 &lt;/p&gt;</summary>
    
    
    
    <category term="java进阶" scheme="https://tig.red/categories/java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="java" scheme="https://tig.red/tags/java/"/>
    
    <category term="jvm" scheme="https://tig.red/tags/jvm/"/>
    
    <category term="锁" scheme="https://tig.red/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>hexo deploy 指定 git 账户</title>
    <link href="https://tig.red/hexodeploy-edit-gitaccount.html"/>
    <id>https://tig.red/hexodeploy-edit-gitaccount.html</id>
    <published>2019-03-04T03:32:31.000Z</published>
    <updated>2021-11-24T07:09:09.730Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;hexo deploy默认使用全局的git user.name user.email，通过设置自定义 git 用户&lt;/p&gt;</summary>
    
    
    
    <category term="计算机操作" scheme="https://tig.red/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C/"/>
    
    
    <category term="hexo" scheme="https://tig.red/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>java内存模型</title>
    <link href="https://tig.red/java-memory-model.html"/>
    <id>https://tig.red/java-memory-model.html</id>
    <published>2019-02-28T15:10:47.000Z</published>
    <updated>2021-11-24T07:09:50.964Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;现代计算机物理内存模型&quot;&gt;&lt;a href=&quot;#现代计算机物理内存模型&quot; class=&quot;headerlink&quot; title=&quot;现代计算机物理内存模型&quot;&gt;&lt;/a&gt;现代计算机物理内存模型&lt;/h3&gt;&lt;p&gt;&lt;img data-src=&quot;https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/memory_model_physical.png&quot; alt=&quot;物理内存模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问局部性&lt;/strong&gt;（英语：Locality of reference）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;访问局部性分为两种基本形式，一种是时间局部性，另一种是空间局部性。时间局部性指的是，程序在运行时，最近刚刚被引用过的一个内存位置容易再次被引用，比如在调取一个函数的时候，前不久才调取过的本地参数容易再度被调取使用。空间局部性指的是，最近引用过的内存位置以及其周边的内存位置容易再次被使用。空间局部性比较常见于循环中，比如在一个数列中，如果第3个元素在上一个循环中使用，则本次循环中极有可能会使用第4个元素。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="java进阶" scheme="https://tig.red/categories/java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="java" scheme="https://tig.red/tags/java/"/>
    
    <category term="jvm" scheme="https://tig.red/tags/jvm/"/>
    
    <category term="jmm" scheme="https://tig.red/tags/jmm/"/>
    
  </entry>
  
  <entry>
    <title>伪共享</title>
    <link href="https://tig.red/false-sharing.html"/>
    <id>https://tig.red/false-sharing.html</id>
    <published>2019-02-28T12:04:04.000Z</published>
    <updated>2021-11-24T07:08:57.708Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;伪共享&quot;&gt;&lt;a href=&quot;#伪共享&quot; class=&quot;headerlink&quot; title=&quot;伪共享&quot;&gt;&lt;/a&gt;伪共享&lt;/h3&gt;&lt;p&gt;在 cpu 和 内存之间有高速缓存区（cache）,cache 一般集成在 cpu 内部，也叫做 cpu Cache。如下图是一个二级缓存示意图。&lt;br&gt;&lt;img data-src=&quot;https://raw.githubusercontent.com/zhouxinghang/resources/master/ZBlog/file.png&quot; alt=&quot;二级缓存示意图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java进阶" scheme="https://tig.red/categories/java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="java" scheme="https://tig.red/tags/java/"/>
    
    <category term="并发编程" scheme="https://tig.red/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
